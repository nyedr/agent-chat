import { OpenAICompatibleProvider } from "@ai-sdk/openai-compatible";
import { generateText } from "ai";
import { Learning } from "./insight-generator";
import { z } from "zod";

/**
 * Interface for report outline section
 */
interface ReportSection {
  title: string;
  content?: string; // Content is filled in as each section is generated
  learningIndices: number[]; // Indices of learnings relevant to this section
}

/**
 * Interface for report outline
 */
interface ReportOutline {
  title: string;
  sections: ReportSection[];
}

/**
 * Schema for report outline generated by LLM
 */
const ReportOutlineSchema = z.object({
  title: z.string(),
  sections: z.array(
    z.object({
      title: z.string(),
      description: z.string().optional(),
      relevantLearnings: z.array(z.number()),
    })
  ),
});

/**
 * Report Generator Module that creates a final research report.
 */
export class ReportGeneratorModule {
  private llmProvider: OpenAICompatibleProvider<string, string, string>;
  private modelId: string;

  /**
   * @param llmProvider - Provider for accessing LLM capabilities
   * @param modelId - ID of the model to use for report generation
   */
  constructor(
    llmProvider: OpenAICompatibleProvider<string, string, string>,
    modelId: string
  ) {
    this.llmProvider = llmProvider;
    this.modelId = modelId;
  }

  /**
   * Generates a final research report.
   *
   * @overload
   * @param learnings - Array of structured learnings with citations
   * @param query - The original research query
   */
  async generateFinalReport(
    learnings: Learning[],
    query: string
  ): Promise<string>;

  /**
   * Implementation of generateFinalReport that handles both overloads.
   */
  async generateFinalReport(
    insightsOrLearnings: Learning[],
    factualAnswerOrQuery: string
  ): Promise<string> {
    // Handle the modern Learning[] format
    const learnings = insightsOrLearnings as Learning[];
    try {
      return this.generateStructuredReport(
        learnings,
        factualAnswerOrQuery // This is the query in this case
      );
    } catch (error) {
      console.error("Error generating structured report:", error);
      return this.generateEmergencyReportFromLearnings(
        learnings,
        factualAnswerOrQuery
      );
    }
  }

  /**
   * Generates a structured report with distinct sections.
   */
  private async generateStructuredReport(
    learnings: Learning[],
    query: string
  ): Promise<string> {
    console.log(
      `Generating structured report for query: "${query}" with ${learnings.length} learnings`
    );

    try {
      // Step 1: Generate report outline
      const outline = await this.generateReportOutline(learnings, query);
      console.log(
        `Generated report outline with ${outline.sections.length} sections`
      );

      // Step 2: Generate introduction
      const introduction = await this.generateIntroduction(
        learnings,
        query,
        outline.title
      );

      // Step 3: Generate each section's content
      const sectionPromises = outline.sections.map((section) =>
        this.generateSectionContent(
          learnings.filter((_, index) =>
            section.learningIndices.includes(index)
          ),
          section.title,
          query
        )
      );

      const sectionContents = await Promise.all(sectionPromises);

      // Update sections with their content
      outline.sections.forEach((section, i) => {
        section.content = sectionContents[i];
      });

      // Step A: Generate conclusion
      const conclusion = await this.generateConclusion(
        learnings,
        query,
        outline
      );

      // Step 5: Generate references section
      const references = this.generateReferences(learnings);

      // Step 6: Assemble the final report
      return this.assembleReport(outline, introduction, conclusion, references);
    } catch (error) {
      console.error("Error in structured report generation:", error);

      return "Error in structured report generation";
    }
  }

  /**
   * Generates a report outline with sections based on learnings.
   */
  private async generateReportOutline(
    learnings: Learning[],
    query: string
  ): Promise<ReportOutline> {
    // Format the learnings for the LLM
    const learningsText = learnings
      .map((learning, index) => {
        return `[${index}] ${learning.text} (Source: ${learning.source})`;
      })
      .join("\n\n");

    const prompt = `You are a research report organizer. Create a detailed outline for a report on: "${query}".

The report should be based on these research findings:

${learningsText}

Analyze these findings and create a logical structure for the report.
Identify 3-6 main sections that would make a comprehensive report.
For each section, identify which of the numbered research findings [0, 1, 2, etc.] should be included.

Return your response in this JSON format only:
{
  "title": "Suggested report title",
  "sections": [
    {
      "title": "First Section Title",
      "description": "Brief description of what this section covers",
      "relevantLearnings": [0, 2, 5] // Indices of relevant learnings
    },
    // Additional sections...
  ]
}

Make sure each learning is assigned to at least one section, and that the sections follow a logical flow.
Return ONLY valid JSON without additional explanation.`;

    // Call the LLM
    const result = await generateText({
      model: this.llmProvider.chatModel(this.modelId),
      prompt,
    });

    // Parse and validate the LLM response
    try {
      // Clean potential markdown code fences and trim whitespace
      const cleanedResponse = result.text
        .trim()
        .replace(/```json\s*|\s*```/g, "");

      // Parse the potentially cleaned JSON
      const parsedResponse = JSON.parse(cleanedResponse);
      const validationResult = ReportOutlineSchema.safeParse(parsedResponse);

      if (!validationResult.success) {
        console.error(
          "LLM outline response validation failed:",
          validationResult.error.format()
        );
        console.error("Raw LLM Response (Outline):", result.text);
        throw new Error("Invalid outline format from LLM"); // Throw to trigger fallback
      }

      const data = validationResult.data;

      // Convert to ReportOutline format
      return {
        title: data.title,
        sections: data.sections.map((section) => ({
          title: section.title,
          learningIndices: section.relevantLearnings,
        })),
      };
    } catch (error) {
      console.error("Failed to generate or parse report outline:", error);
      // Log the raw response if parsing failed
      if (error instanceof SyntaxError) {
        console.error(
          "Raw LLM Response (Outline) causing parse failure:",
          result.text
        );
      }
      // Fallback to a simple outline
      return {
        title: `Research Report: ${query}`,
        sections: [
          {
            title: "Key Findings",
            learningIndices: learnings.map((_, index) => index), // Include all learnings
          },
        ],
      };
    }
  }

  /**
   * Generates introduction section for the report.
   */
  private async generateIntroduction(
    learnings: Learning[],
    query: string,
    reportTitle: string
  ): Promise<string> {
    // Create a concise prompt for the introduction
    const prompt = `Write a professional introduction for a research report titled "${reportTitle}" that addresses the query: "${query}".

The introduction should:
1. Present the research question/topic clearly
2. Provide brief context for why this topic is important or relevant
3. Outline the scope of the research
4. Briefly mention the methodology (literature review, data analysis, etc.)
5. Preview the main findings without details

Keep the introduction concise (200-300 words), engaging, and suitable for an academic or professional audience.
Write in markdown format.`;

    // Call the LLM
    const result = await generateText({
      model: this.llmProvider.chatModel(this.modelId),
      prompt,
    });

    return result.text;
  }

  /**
   * Generates content for a specific section based on relevant learnings.
   */
  private async generateSectionContent(
    relevantLearnings: Learning[],
    sectionTitle: string,
    query: string
  ): Promise<string> {
    if (relevantLearnings.length === 0) {
      return `## ${sectionTitle}\n\nNo specific findings were available for this section.`;
    }

    // Format the learnings for the LLM
    const learningsText = relevantLearnings
      .map((learning, index) => {
        return `[${index + 1}] ${learning.text} (Source: ${learning.source})`;
      })
      .join("\n\n");

    const prompt = `Write the content for the "${sectionTitle}" section of a research report on "${query}".

Use the following research findings to write this section:

${learningsText}

Guidelines:
- Begin with a clear topic sentence that introduces this section's focus
- Synthesize and connect the findings (don't just list them)
- Compare/contrast different findings when relevant
- Extract insights that aren't explicitly stated but can be inferred
- Cite the sources using the source information provided
- Format in markdown with appropriate subheadings if needed
- Keep the section focused on the topic indicated by its title
- Write in a professional, academic tone
- Length should be 300-500 words, proportional to the amount of findings

Return just the section content in markdown format.`;

    // Call the LLM
    const result = await generateText({
      model: this.llmProvider.chatModel(this.modelId),
      prompt,
    });

    // Ensure the section title is included
    if (!result.text.startsWith("#")) {
      return `## ${sectionTitle}\n\n${result.text}`;
    }

    return result.text;
  }

  /**
   * Generates conclusion section for the report.
   */
  private async generateConclusion(
    learnings: Learning[],
    query: string,
    outline: ReportOutline
  ): Promise<string> {
    // Extract major themes from section titles
    const themesText = outline.sections
      .map((section) => section.title)
      .join(", ");

    const prompt = `Write a conclusion for a research report titled "${outline.title}" that addresses the query: "${query}".

The report covered these main themes: ${themesText}.

Your conclusion should:
1. Summarize the key findings without introducing new information
2. Synthesize insights across different sections
3. Address the original research question directly
4. Discuss implications of the findings
5. Mention limitations of the research if applicable
6. Suggest areas for future research

Write in a professional, academic tone. Format in markdown and keep the conclusion concise (200-300 words).`;

    // Call the LLM
    const result = await generateText({
      model: this.llmProvider.chatModel(this.modelId),
      prompt,
    });

    // Ensure proper heading
    if (!result.text.startsWith("#")) {
      return `## Conclusion\n\n${result.text}`;
    }

    return result.text;
  }

  /**
   * Generates references section for the report.
   */
  private generateReferences(learnings: Learning[]): string {
    // Extract unique sources
    const uniqueSources = new Map<string, Set<string>>();

    for (const learning of learnings) {
      const source = learning.source;
      if (!uniqueSources.has(source)) {
        uniqueSources.set(source, new Set());
      }
    }

    // Format references
    let referencesSection = "## References\n\n";

    Array.from(uniqueSources.keys())
      .sort()
      .forEach((source, index) => {
        referencesSection += `${index + 1}. ${source}\n`;
      });

    return referencesSection;
  }

  /**
   * Assembles the final report from all generated sections.
   */
  private assembleReport(
    outline: ReportOutline,
    introduction: string,
    conclusion: string,
    references: string
  ): string {
    // Format title
    let report = `# ${outline.title}\n\n`;

    // Add introduction
    if (!introduction.startsWith("#")) {
      report += `## Introduction\n\n`;
    }
    report += `${introduction}\n\n`;

    // Add each section
    for (const section of outline.sections) {
      if (section.content) {
        report += `${section.content}\n\n`;
      } else {
        report += `## ${section.title}\n\n(Section content unavailable)\n\n`;
      }
    }

    // Add conclusion
    report += `${conclusion}\n\n`;

    // Add references
    report += `${references}\n\n`;

    // Add timestamp
    report += `\n\n*Report generated: ${new Date().toISOString()}*`;

    return report;
  }

  /**
   * Generates a very simple emergency report when other methods fail.
   */
  private generateEmergencyReportFromLearnings(
    learnings: Learning[],
    query: string
  ): string {
    // Group learnings by source
    const sourceMap: Record<string, Learning[]> = {};

    for (const learning of learnings) {
      const source = learning.source || "Unknown source";
      if (!sourceMap[source]) {
        sourceMap[source] = [];
      }
      sourceMap[source].push(learning);
    }

    // Create a basic report
    let report = `# Research Report: ${query}\n\n`;

    // Add a simple summary
    report += `## Summary\n\nThis report presents findings related to "${query}" based on ${learnings.length} research insights.\n\n`;

    // Add key findings grouped by source
    report += `## Key Findings\n\n`;

    Object.entries(sourceMap).forEach(([source, sourceLearnings]) => {
      report += `### From ${source}\n\n`;

      sourceLearnings.forEach((learning, index) => {
        report += `${index + 1}. ${learning.text}\n\n`;
      });
    });

    report += `\n*Note: This is a basic report generated due to an error in the standard report generation process.*\n`;

    return report;
  }
}
